name: End-to-End CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  provision-infrastructure:
    name: Provision Infrastructure with Terraform
    runs-on: ubuntu-latest
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      TF_VAR_client_id: ${{ secrets.AZURE_CLIENT_ID }}
      TF_VAR_client_secret: ${{ secrets.AZURE_CLIENT_SECRET }}
      TF_VAR_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      TF_VAR_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
      TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Terraform Init with Remote Backend
        run: |
          cd azure-terraform
          terraform init

      - name: Terraform Apply for Main Infrastructure
        run: |
          cd azure-terraform
          terraform apply -auto-approve

  configure-vm:
    name: Configure VM with Ansible
    runs-on: ubuntu-latest
    needs: provision-infrastructure
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Fetch VM Public IP from Remote State
        id: fetch_ip
        run: |
          cd azure-terraform
          terraform init
          echo "::set-output name=vm_public_ip::$(terraform output -raw vm_public_ip)"

      - name: Set up SSH Key
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ssh_key.pem
          chmod 600 ssh_key.pem

      - name: SSH into VM to Install Ansible and Run Playbook
        run: |
          ssh -o "StrictHostKeyChecking=no" -i ssh_key.pem azureuser@${{ steps.fetch_ip.outputs.vm_public_ip }} << EOF
            sudo apt update
            sudo apt install -y ansible

            mkdir -p ~/ansible-playbooks
            echo '${{ toJSON(github.event.head_commit.message) }}' > ~/ansible-playbooks/install_docker-kubernetics.yml
            ansible-playbook -i "localhost," -c local ~/ansible-playbooks/install_docker-kubernetics.yml
          EOF
        shell: bash

  build-and-push-docker:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: configure-vm
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Fetch ACR Credentials from Remote State
        id: fetch_acr
        run: |
          cd azure-terraform
          terraform init
          echo "::set-output name=acr_login_server::$(terraform output -raw acr_login_server)"
          echo "::set-output name=acr_username::$(terraform output -raw acr_username)"
          echo "::set-output name=acr_password::$(terraform output -raw acr_password)"

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ steps.fetch_acr.outputs.acr_login_server }}
          username: ${{ steps.fetch_acr.outputs.acr_username }}
          password: ${{ steps.fetch_acr.outputs.acr_password }}

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ steps.fetch_acr.outputs.acr_login_server }}/frontend:v1 -f frontend/Dockerfile .
          docker push ${{ steps.fetch_acr.outputs.acr_login_server }}/frontend:v1

      - name: Build and Push Backend Image
        run: |
          docker build -t ${{ steps.fetch_acr.outputs.acr_login_server }}/backend:v1 -f backend/Dockerfile .
          docker push ${{ steps.fetch_acr.outputs.acr_login_server }}/backend:v1

  deploy-to-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push-docker
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Fetch VM Public IP from Remote State
        id: fetch_ip
        run: |
          cd azure-terraform
          terraform init
          echo "::set-output name=vm_public_ip::$(terraform output -raw vm_public_ip)"

      - name: Set up SSH Key
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ssh_key.pem
          chmod 600 ssh_key.pem

      - name: Replace ACR Login Server in Kubernetes Manifests
        run: |
          sed -i "s|{{ ACR_LOGIN_SERVER }}|${{ steps.fetch_acr.outputs.acr_login_server }}|g" k8s-manifests/*.yaml

      - name: Copy Kubernetes Manifests to VM
        run: |
          scp -o "StrictHostKeyChecking=no" -i ssh_key.pem k8s-manifests/*.yaml azureuser@${{ steps.fetch_ip.outputs.vm_public_ip }}:/home/azureuser/

      - name: SSH into VM and Apply Kubernetes Configs
        run: |
          ssh -o "StrictHostKeyChecking=no" -i ssh_key.pem azureuser@${{ steps.fetch_ip.outputs.vm_public_ip }} << EOF
            kubectl create namespace my-namespace
            kubectl apply -f /home/azureuser/mongodb_deployment.yaml -n my-namespace
            kubectl apply -f /home/azureuser/backend_deployment.yaml -n my-namespace
            kubectl apply -f /home/azureuser/frontend_deployment.yaml -n my-namespace
          EOF
