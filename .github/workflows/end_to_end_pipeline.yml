name: End-to-End CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  setup-backend:
    name: Setup Terraform Backend in Azure Blob Storage
    runs-on: ubuntu-latest
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Terraform Init and Apply for Backend
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          cd backend-setup
          terraform init
          terraform apply -auto-approve

  provision-infrastructure:
    name: Provision Infrastructure with Terraform
    runs-on: ubuntu-latest
    needs: setup-backend
    outputs:
      vm_public_ip: ${{ steps.get_ip.outputs.vm_public_ip }}
      acr_login_server: ${{ steps.get_ip.outputs.acr_login_server }}
      acr_username: ${{ steps.get_ip.outputs.acr_username }}
      acr_password: ${{ steps.get_ip.outputs.acr_password }}
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Terraform Init with Remote Backend
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          cd azure-terraform
          terraform init

      - name: Terraform Apply for Main Infrastructure
        id: apply
        run: |
          cd azure-terraform
          terraform apply -auto-approve -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}"

      - name: Retrieve Outputs from Terraform State
        id: get_ip
        run: |
          cd azure-terraform
          echo "::set-output name=vm_public_ip::$(terraform output -raw vm_public_ip)"
          echo "::set-output name=acr_login_server::$(terraform output -raw acr_login_server)"
          echo "::set-output name=acr_username::$(terraform output -raw acr_username)"
          echo "::set-output name=acr_password::$(terraform output -raw acr_password)"

  configure-vm:
    name: Configure VM with Ansible
    runs-on: ubuntu-latest
    needs: provision-infrastructure
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up SSH Key
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ssh_key.pem
          chmod 600 ssh_key.pem

      - name: SSH into VM to Install Ansible and Run Playbook
        run: |
          ssh -o "StrictHostKeyChecking=no" -i ssh_key.pem azureuser@${{ needs.provision-infrastructure.outputs.vm_public_ip }} << EOF
            sudo apt update
            sudo apt install -y ansible

            mkdir -p ~/ansible-playbooks
            echo '${{ toJSON(github.event.head_commit.message) }}' > ~/ansible-playbooks/install_docker-kubernetics.yml
            ansible-playbook -i "localhost," -c local ~/ansible-playbooks/install_docker-kubernetics.yml
          EOF
        shell: bash

  build-and-push-docker:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: configure-vm
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ needs.provision-infrastructure.outputs.acr_login_server }}
          username: ${{ needs.provision-infrastructure.outputs.acr_username }}
          password: ${{ needs.provision-infrastructure.outputs.acr_password }}

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ needs.provision-infrastructure.outputs.acr_login_server }}/frontend:v1 -f frontend/Dockerfile .
          docker push ${{ needs.provision-infrastructure.outputs.acr_login_server }}/frontend:v1

      - name: Build and Push Backend Image
        run: |
          docker build -t ${{ needs.provision-infrastructure.outputs.acr_login_server }}/backend:v1 -f backend/Dockerfile .
          docker push ${{ needs.provision-infrastructure.outputs.acr_login_server }}/backend:v1

  deploy-to-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push-docker
    steps:
      - name: Check out the code
        uses: actions/checkout@v2

      - name: Set up SSH Key
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ssh_key.pem
          chmod 600 ssh_key.pem

      - name: Replace ACR Login Server in Kubernetes Manifests
        run: |
          sed -i "s|{{ ACR_LOGIN_SERVER }}|${{ needs.provision-infrastructure.outputs.acr_login_server }}|g" k8s-manifests/*.yaml

      - name: Copy Kubernetes Manifests to VM
        run: |
          scp -o "StrictHostKeyChecking=no" -i ssh_key.pem k8s-manifests/*.yaml azureuser@${{ needs.provision-infrastructure.outputs.vm_public_ip }}:/home/azureuser/

      - name: SSH into VM and Apply Kubernetes Configs
        run: |
          ssh -o "StrictHostKeyChecking=no" -i ssh_key.pem azureuser@${{ needs.provision-infrastructure.outputs.vm_public_ip }} << EOF
            kubectl create namespace my-namespace
            kubectl apply -f /home/azureuser/mongodb_deployment.yaml -n my-namespace
            kubectl apply -f /home/azureuser/backend_deployment.yaml -n my-namespace
            kubectl apply -f /home/azureuser/frontend_deployment.yaml -n my-namespace
          EOF
